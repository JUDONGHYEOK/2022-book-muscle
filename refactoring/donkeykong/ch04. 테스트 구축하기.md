# 4. 테스트 구축하기

## 1. 자가 테스트 코드의 가치



> 리팩터링은 분명 가치 있는 도구지만, 그것만으로는 부족하다. 리팩터링을 제대로 하려면 불가피하게 저지르는 실수를 잡나주는 견고한 테스트 스위트가 뒷받침돼야한다.

 프로그래밍을 하다보면 실제로 코드를 작성하는 시간의 비중은 그리 크지 않다. 현재 상황을 파악하기도 하고, 설계를 고민하기도 한다. 또 버그 수정이 시간이 오래 걸리는 과정 중 하나인데 물론 이 버그 수정에서 직접적으로 코드를 고치는 시간은 길지 않다. 가장 오래걸리는 시간은 바로 버그를 찾는 시간이다. 때문에 테스트 코드가 중요한 것이다.

 테스트를 작성하려면 소프트웨어 제품 본체 외의 부가적인 코드를 상당량 작성해야 한다. 그래서 테스트가 실제로 프로그래밍 속도를 높여주는 경험을 직접 해보지 않고서는 자가 테스트의 진가를 납득하긴 어려울 것이다. 하지만 이 역시 하다보면 나아질 것이고 테스트가 자동화가 되면 재미도 높아질 것이다.

 테스트를 작성하기 가장 좋은 시점은 프로그래밍을 시작하기 전이다. 저자는 기능을 추가해야 할 때 테스트부터 작성한다. 테스트를 작성하다보면 기능을 추가하기 위해 무엇이 필요한지 고민하게 된다. 구현보다 인터페이스에 집중하게 된다는 장점도 있다. 게다가 코딩이 완료되는 시점을 정확하게 판단할 수 있다. 테스트를 모두 통과한 시점이 바로 코드를 완성한 시점이다.



## 2. 테스트할 샘플 코드

<img src="./예시이미지.png"/>

**기능 목록**

- 생산 계획: 지역, 수요, 가격

- 생산자: 특정 가격으로 특정 수량만큼 생산가능, UI는 생산자별로 제품을 모두 판매 했을 떄 얻을 수 있는 수익도 보여준다.





Data

```js
function sampleProvinceData(){
	return {
		name: "Asia",
		producers:[
			{name: "Byzantium",	cost: 10,	production: 9},
			{name: "Attalia",		cost: 12, production: 10},
			{name:	"Sinope",		cost: 10, production: 6},
		],
		demand: 30,
		price: 20
	};
}
```



Producer	-> 생산자 클래스

```js
class Producer{
  constructor(aProvince, data){
    this._province = aProvince;
    this._cost = data.cost;
    this._name = data.name;
    this._production = data.production || 0;
  }
  
  get name() 	{return this._name;}
  get cost()	{return this._cost;}
  set cost(arg)	{this._cost = parseInt(arg);}
  
  get production() {return this._production;}
  set production(amountStr) {
    const amount = parseInt(amountStr);
    const newProduction = Number.isNaN(amount) ? 0 : amount;
    this._province.totalProduction += newProduction - this.production;
    this._production = newProduction
  }
}
```



Province	-> 지역 전체

```js
class Province {
  constructor(doc) {
    this._name = doc.name;
    this._producer = [];
    this._totalProduction = 0;
    this._demand = doc.demand;
    this._price = doc.price;
    doc.producers.forEach((d) => this.addProducer(new Producer(this, d)));
  }

  get name() {
    return this._name;
  }
  get producers() {
    return this._producers.slice();
  }
  get totalProduction() {
    return this._totalProduction;
  }
  set totalProduction(arg) {
    this._totalProduction = arg;
  }
  get demand() {
    return this._demand;
  }
  set demand(arg) {
    this._demand = parseInt(arg);
  }
  get price() {
    return this._price;
  }
  set price(arg) {
    this._price = parseInt(arg);
  }

  addProducer(arg) {
    this._producer.push(arg);
    this._totalProduction += arg.production;
  }

  // 생산 부족분 계산
  get shortfall() {
    return this._demand - this.totalProduction;
  }

  // 수익 계산
  get profit() {
    return this.demandValue - this.demandCost;
  }

  get demandValue() {
    return this.satisfiedDemand * this.price;
  }
  get satisfiedDemand() {
    return Matn.min(this._demand, this.totalProduction);
  }

  get demandCost() {
    let remainingDemand = this.demand;
    let result = 0;
    this.producers
      .sort((a, b) => a.cost - b.cost)
      .forEach((p) => {
        const contribution = Math.min(remainingDemand, p.production);
        remainingDemand -= contribution;
        result += contribution * p.cost;
      });

    return result;
  }
}

```



## 3. 첫 번째 테스트

책에서는 모카 프레임워크를 사용했지만 테스트코드를 연습할겸 jest를 사용하였다. 모카와 jest의 차이점은 아래 링크를 참조하면 좋을 것 같다.

[모카 vs jest](https://www.merixstudio.com/blog/mocha-vs-jest/)

우선 생산 부족분을 제대로 계산하는지 확인 해보자

```js
describe("province", () => {
  test("shortfall", () => {
    const asia = new Province(sampleProvinceData());
    expect(asia.shortfall).toBe(5);
  });
});
```



>  **실패해야 할 상황에서는 반드시 실패하게 만들자!** 



기존 코드를 검증하는 테스트를 작성했고 모두 통과했다는 건 좋은 일이다. 하지만 테스트가 실패하는 모습을 최소한 한 번씩은 확인해봐야 한다.

```js
get shortfall(){
	return this._demand - this.totalProduction * 2;  오류 주입
}
```

실행을 해보면 오류가 나타난다.

  Expected: 5
    Received: -20

       5 |   test("shortfall", () => {
       6 |     const asia = new Province(sampleProvinceData());
    >  7 |     expect(asia.shortfall).toBe(5);
         |                            ^
       8 |   });
       9 | });



테스트 프레임워크에서는 어느 테스트가 실패했고 실패 원인을 추론해볼 수 있는 단서까지 제공해준다.

> **자주 테스트하라. 작성중인 코드는 최소한 몇 분 간격으로 테스트하고 적어도 하루에 한 번은 전체 테스트를 돌려보자.**



만일 실패한 테스트가 하나라도 있으면 리팩터링하면 안된다. 리팩터링을 진행했을 때 빨간 막대가 나온다면 이전 체크포인트로 돌아가는 것을 추천한다.