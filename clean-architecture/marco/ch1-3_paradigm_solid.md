# 클린 아키텍처(로버트 C.마틴)

- 정리: 마르코
- 아키텍처 규칙은 동일하다!
- 제대로 된 소프트웨어를 만들면 아주 적은 인력만으로도 새로운 기능을 추가하거나 유지보수 할 수 있다.
  - 결합률이 극도로 낮은 시스템일 경우, 최소한의 노력으로 기능과 유연성을 최대화할 수 있다.
  - 반대로 시스템이 서로 강하게 연관되고 있고 복잡하게 결합될 경우, 아주 사소한 변경에도 몇 주가 걸리고 큰 위험을 감수해야 할 수 있다.

## 1장. 설계와 아키텍처란?

- 설계(design)와 아키텍처는 같다.
- 좋은 소프트웨어 설계의 목표 : 필요한 시스템을 만들고 유지보수하는 데 투입되는 인력을 최소화하는 데 있다.
- "빨리 가는 유일한 방법은 제대로 가는 것이다."

## 2장. 두 가지 가치에 대한 이야기

- 아키텍처는 형태에 독립적이어야 하고, 그럴수록 더 실용적이다.
- 패러다임이란 프로그래밍을 하는 방법으로, 대체로 언어에는 독립적이다. 패러다임은 어떤 프로그래밍 구조를 사용할지, 그리고 언제 이 구조를 사용해야 하는지를 결정한다. 현재까지 이러한 패러다임에는 세 가지 종류가 있다.

## 3장. 패러다임 개요

- 구조적 프로그래밍, 객체지향 프로그래밍, 함수형 프로그래밍에 대해 설명한다.

### 구조적 프로그래밍

- 1968년, Edsger Wybe Dijksta가 발견
- **구조적 프로그래밍은 제어흐름의 직접적인 전환에 대한 규칙을 부과한다.** (goto문 뺏김)

### 객체 지향 프로그래밍

- 1966년, Ole Johna Dahl, Kristen Nyggard에 의해 등장
- 함수 호출 스택 프레임을 힙으로 옮기면, 함수 호출이 반환된 이후에도 함수에서 선언된 지역 변수가 오랫동안 유지될 수 있음을 발견했다. 바로 이러한 함수가 `클래스의 생성자`가 되었고, 지역 변수는 `인스턴스 변수`, 그리고 중첩 함수는 `메서드`가 되었다. 함수 포인터를 특정 규칙에 따라 사용하는 과정을 통해 필연적으로 `다형성`이 등장하게 되었다.
- **객체 지향 프로그래밍은 제어흐름의 간접적인 전환에 대한 규칙을 부과한다.** (함수 포인터 뺏김)

### 함수형 프로그래밍

- 최근에 들어서야 도입되기 시작했지만, 세 패러다임 중 가장 먼저 만들어졌다.
- 수학적 문제를 해결하는 'Lamda' 계산법이 근간이 되었다. 람다 계산법의 기초가 되는 개념은 불변성으로, 심볼의 값이 변경되지 않는다는 개념이다. 이는 함수형 언어에는 할당문이 전혀 없다는 뜻이기도 하다.
- **함수형 프로그래밍은 할당문에 대한 규칙을 부과한다.** (할당문 뺏김)

### 생각할 거리

- 각 패러다임은 프로그래머에게서 권한을 박탈한다. 즉, 추가 규칙을 부과하는 것이며, 무엇을 해야 할지를 말하기보다는 무엇을 해서는 안 되는지를 말해준다.
- 이후로 새롭게 등장한 패러다임은 전혀 없다.

## 4장. 구조적 프로그래밍

- 현재의 우리 모두는 구조적 프로그래머이다. 제어흐름을 제약 없이 직접 전환할 수 있는 선택권 자체를 언어에서 제공하지 않기 때문이다.
- 구조적 프로그래밍은 프로그램을 증명 가능한 세부 기능 집합으로 재귀적으로 분해할 것을 강요한다. 그리고 나서 테스트를 통해 증명 가능한 세부 기능들이 거짓인지를 증명하려고 시도한다. 이처럼 거짓임을 증명하려는 테스트가 실패한다면, 이 기능들은 목표에 부합할 만큼 충분히 참이라고 여기게 된다.
- 구조적 프로그래밍이 오늘날까지 가치 있는 이유는 프로그래밍에서 반증 가능한 단위를 만들어낼 수 있는 바로 이 능력 때문이다.

## 5장. 객체 지향 프로그래밍

- 다형성이 가진 힘
  - 일반적으로 제어 흐름은 시스템의 행위에 따라 결정되며, 소스 코드의 의존성은 제어 흐름에 따라 결정된다. 이 때문에 제어 흐름의 방향은 항상 고수준 로직에서 저수준 로직으로 향하게 된다.
  - 하지만 고수준 로직에서 저수준 로직으로 흘러가는 흐름 사이에 추상 로직을 둠으로써 다형성을 만들 수 있다.
    - 기존에는 `고수준 로직 -> 저수준 로직` 이었다면, 다형성을 적용한 후 `고수준 로직 -> '추상 로직' <- 저수준 로직`이 된다.
    - -> 으로 만 흘러가던 제어 흐름의 방향에 의존성을 역전한 것이다.
- 의존성 역전
  - 객체지향 언어가 다형성을 안전하고 편리하게 제공한다는 사실은 소스 코드 의존성을 어디에서든 역전시킬 수 있다는 뜻이기도 하다.
  - 이 힘으로 예를 들어 업무 규칙이 데이터베이스와 사용자 인터페이스에 의존하는 대신에, 시스템의 소스 코드 의존성을 반대로 배치하여 데이터베이스와 UI가 업무 규칙에 의존하게 만들 수 있다.
    - 즉, 업무 규칙의 소스코드에서는 UI나 데이터베이스를 호출(의존)하지 않는다.
    - 따라서 업무 규칙을 UI와 데이터베이스와는 독립적으로 배포할 수 있다. 이는 개발 독립성으로 이어진다.
- 결론
  - 객체지향이란 다형성을 이용하여 전체 시스템의 모든 소스 코드 의존성에 대한 절대적인 제어 권한을 획득할 수 있는 능력이다.
    - 이를 통해 고수준의 정책을 포함하는 모듈은 저수준의 세부사항을 포함하는 모듈에 대해 독립성을 보장할 수 있다. 저수준의 세부사항은 중요도가 낮은 플러그인 모듈로 만들 수 있고, 고수준의 정책을 포함하는 모듈과는 독립적으로 개발하고 배포할 수 있다.

## 6장. 함수형 프로그래밍

- 함수형 언어에서 변수는 변경되지 않는다.

### 불변성과 아키텍처

- 아키텍처는 왜 변수의 가변성을 염려하는가?
  - 경합 조건, 교착상태 조건, 동시 업데이트 문제가 모두 `가변 변수`로 인해 발생하기 때문이다.
- 그러나 저장공간이 무한하지 않고 프로세스 속도 또한 무한히 빠르지 않으므로, 불변성은 일종의 타협을 해야 한다.

### 가변성의 분리

- 불변성과 관련하여 가장 중요한 타협 중 하나는 애플리케이션 또는 애플리케이션 내부의 서비스를 가변 컴포넌트와 불변 컴포넌트로 분리하는 일이다. -불변 컴포넌트에서는 순수하게 함수형 방식으로만 작업이 처리된다.
  - 현명한 아키텍트라면 가능한 한 많은 처리를 불변 컴포넌트로 옮겨야 하고, 가변 컴포넌트에서는 가능한 한 많은 코드를 빼내야 한다.

### 이벤트 소싱

- 이벤트 소싱은 상태가 아닌 트랜잭션을 저장하자는 전략이다. 상태가 필요해지면 단순히 상태의 시작점부터 모든 트랜잭션을 처리한다.
  - 데이터 저장소에서 삭제되거나 변경되는 것이 하나도 없다. 결과적으로 애플리케이션은 CRUD가 아니라 그저 CR만 수행한다. 데이터 저장소에서 변경과 삭제가 전혀 발생하지 않으므로 동시 업데이트 문제도 일어나지 않는다.
- 즉, 저장 공간과 처리 능력이 충분하면 애플리케이션이 완전한 불변성을 갖도록 만들 수 있고, 따라서 완전한 함수형으로 만들 수 있다.
- 소스 코드 버전 관리 시스템이 정확히 이 방식으로 동작한다.

### 결론

- 구조적 프로그래밍은 `제어흐름의 직접적인 전환`에 부과되는 규율이다.
- 객체 지향 프로그래밍은 `제어흐름의 간접적인 전환`에 부과되는 규율이다.
- 함수형 프로그래밍은 `변수 할당`에 부과되는 규율이다.

# 3부. 설계 원칙

- SOLID 원칙
  - SRP : 단일 책임 원칙(single responsibility principle)
  - OCP : 개방-폐쇄 원칙(open-closed principle)
  - LSP : 리스코프 치환 원칙(Liskov substitution principle)
  - ISP: 인터페이스 분리 원칙(interface segregation principle)
  - DIP: 의존성 역전 원칙(dependency inversion principle)

## 7장. SRP: 단일 책임 원칙

- "함수는 반드시 하나의 일만 해야 한다"는 원칙은 SOLID의 SRP와 관련되지 않는다.
- SRP 원칙
  - 하나의 모듈(소스 파일)은 하나의 액터에 대해서만 책임져야 한다.

### 징후1: 우발적 중복

- SRP는 서로 다른 액터가 의존하는 코드를 서로 분리하라고 말한다.

### 징후2: 병합

- 병합 문제에 대한 가장 확실한 해결책은 데이터와 메서드를 분리하는 방식이다.
- 반면 이 해결책은 개발자가 세 가지 크랠스를 인스턴스화하고 추적해야 한다는 게 단점이다.
  - 이를 해결하기 위한 기법으로 `퍼사드(Facade) 패턴`이 있다.
    - 퍼사드 패턴을 통해 새로 만든 클래스에는 코드가 거의 없고, 다른 클래스의 객체를 생성하고, 요청된 메서드를 가지는 객체로 위임하는 일을 책임진다.

## 8장. OCP: 개방-폐쇄 원칙

- "소프트웨어 개체(artifact)는 확장에는 열려 있어야 하고, 변경에는 닫혀 있어야 한다."
- A컴포넌트에서 발생한 변경으로부터 B컴포넌트를 보호하려면 반드시 A컴포넌트가 B컴포넌트에 의존해야 한다.
- 아키텍트는 기능이 어떻게, 왜, 언제 발생하는지에 따라서 기능을 분리하고, 분리한 기능을 컴포넌트의 계층구조로 조직화한다. 컴포넌트의 계층구조를 이와 같이 조직화하면 저수준 컴포넌트에서 발생한 변경으로부터 고수준 컴포넌트를 보호할 수 있다.
- 방향성 제어
- 정보 은닉
- OCP의 목표는 시스템을 확장하기 쉬운 동시에 변경으로 인해 시스템이 너무 많은 영향을 받지 않도록 하는 데 있다. 이러한 목표를 달성하려면 시스템을 컴포넌트 단위로 분리하고, 저수준 컴포넌트에서 발생한 변경으로부터 고수준 컴포넌트를 보호할 수 있는 형태의 의존성 계층구조가 만들어지도록 해야 한다.

## 9장. LSP: 리스코프 치환 원칙

- "여기에서 필요한 것은 다음과 같은 치환 원칙이다. S 타입의 객체 o1 각각에 대응하는 T 타입 객체 o2가 있고, T 타입을 이용해서 정의한 모든 프로그램 P에서 o2의 자리에 o1을 치환하더라도 P의 행위가 변화지 않는다면, `S는 T의 하위 타입이다`."
- 상속을 사용하도록 가이드하기
- 정사각형/직사각형 문제
- LSP는 아키텍처 수준까지 확장할 수 있고, 반드시 확장해야만 한다. 치환 가능성을 조금이라도 위배하면 시스템 아키텍처가 오염되어 상당량의 별도 메커니즘을 추가해야 할 수 있기 때문이다.
